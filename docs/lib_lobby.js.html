

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Source: lib/lobby.js | dota-ihl-bot</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-jsdoc.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/tui-doc.css">

    
</head>
<body>
<nav class="lnb" id="lnb">
    <div class="logo" style="">
        
            <img src="img/toast-ui.png" width="100%" height="100%">
        
    </div>
    <div class="title">
        <h1><a href="index.html" class="link">dota-ihl-bot</a></h1>
        
            <span class="version">v0.0.0</span>
        
    </div>
    <div class="search-container" id="search-container">
        <input type="text" placeholder="Search">
        <ul></ul>
    </div>
    
    <div class="lnb-api hidden"><h3>Modules</h3><ul><li><a href="module-client.html">client</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:client_sub"></div></li><li><a href="module-constants.html">constants</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:constants_sub"></div></li><li><a href="module-db.html">db</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:db_sub"><div class="member-type">Typedef</div><ul class="inner"><li><a href="module-db.html#.League">League</a></li><li><a href="module-db.html#.User">User</a></li></ul></div></li><li><a href="module-dotaBot.html">dotaBot</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:dotaBot_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="module-dotaBot.html#~isDotaLobbyReady">isDotaLobbyReady</a></li><li><a href="module-dotaBot.html#~slotToFaction">slotToFaction</a></li><li><a href="module-dotaBot.html#~updatePlayerState">updatePlayerState</a></li></ul><div class="member-type">Typedef</div><ul class="inner"><li><a href="module-dotaBot.html#.LogOnDetails">LogOnDetails</a></li></ul></div></li><li><a href="module-guild.html">guild</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:guild_sub"></div></li><li><a href="module-ihl.html">ihl</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:ihl_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="module-ihl.html#~addLobbyToInhouse">addLobbyToInhouse</a></li><li><a href="module-ihl.html#~banInhouseQueue">banInhouseQueue</a></li><li><a href="module-ihl.html#~checkInhouseQueue">checkInhouseQueue</a></li><li><a href="module-ihl.html#~createInhouseState">createInhouseState</a></li><li><a href="module-ihl.html#~createNewLobbyForInhouse">createNewLobbyForInhouse</a></li><li><a href="module-ihl.html#~getUserRankTier">getUserRankTier</a></li><li><a href="module-ihl.html#~joinInhouseQueue">joinInhouseQueue</a></li><li><a href="module-ihl.html#~leaveInhouseQueue">leaveInhouseQueue</a></li><li><a href="module-ihl.html#~loadLobbiesIntoInhouse">loadLobbiesIntoInhouse</a></li><li><a href="module-ihl.html#~registerUser">registerUser</a></li><li><a href="module-ihl.html#~removeLobbyFromInhouse">removeLobbyFromInhouse</a></li><li><a href="module-ihl.html#~runLobbiesForInhouse">runLobbiesForInhouse</a></li></ul><div class="member-type">Typedef</div><ul class="inner"><li><a href="module-ihl.html#.InhouseState">InhouseState</a></li></ul></div></li><li><a href="module-ihlManager.html">ihlManager</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:ihlManager_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="module-ihlManager.html#~ihlManager">ihlManager</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="module-ihlManager.html#~addInhouseState">addInhouseState</a></li><li><a href="module-ihlManager.html#~findUser">findUser</a></li><li><a href="module-ihlManager.html#~getIndexOfInhouseState">getIndexOfInhouseState</a></li><li><a href="module-ihlManager.html#~getInhouseState">getInhouseState</a></li><li><a href="module-ihlManager.html#~getLobbyByChannelId">getLobbyByChannelId</a></li><li><a href="module-ihlManager.html#~getLobbyByLobbyName">getLobbyByLobbyName</a></li><li><a href="module-ihlManager.html#~getLobbyFromMessage">getLobbyFromMessage</a></li><li><a href="module-ihlManager.html#~isMessageFromAdmin">isMessageFromAdmin</a></li><li><a href="module-ihlManager.html#~loadInhouseState">loadInhouseState</a></li><li><a href="module-ihlManager.html#~loadInhouseStates">loadInhouseStates</a></li><li><a href="module-ihlManager.html#~loadInhouseStatesFromLeagues">loadInhouseStatesFromLeagues</a></li><li><a href="module-ihlManager.html#~transformLeagueGuild">transformLeagueGuild</a></li></ul><div class="member-type">Events</div><ul class="inner"><li><a href="module-ihlManager.html#~event:EVENT_MATCH_ENDED">EVENT_MATCH_ENDED</a></li><li><a href="module-ihlManager.html#~event:EVENT_PICK_PLAYER">EVENT_PICK_PLAYER</a></li><li><a href="module-ihlManager.html#~event:EVENT_PLAYER_READY">EVENT_PLAYER_READY</a></li><li><a href="module-ihlManager.html#~event:EVENT_PLAYERS_READY">EVENT_PLAYERS_READY</a></li></ul><div class="member-type">Typedef</div><ul class="inner"><li><a href="module-ihlManager.html#.LeagueGuildObject">LeagueGuildObject</a></li><li><a href="module-ihlManager.html#~eventCallback">eventCallback</a></li></ul></div></li><li><a href="module-lobby.html">lobby</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:lobby_sub"><div class="member-type">Typedef</div><ul class="inner"><li><a href="module-lobby.html#.LobbyState">LobbyState</a></li></ul></div></li><li><a href="module-matchTracker.html">matchTracker</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:matchTracker_sub"></div></li></ul></div><div class="lnb-api hidden"><h3>Externals</h3><ul><li><a href="external-CategoryChannel.html">CategoryChannel</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="external:CategoryChannel_sub"></div></li><li><a href="external-Client.html">Client</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="external:Client_sub"></div></li><li><a href="external-Command.html">Command</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="external:Command_sub"></div></li><li><a href="external-EventEmitter.html">EventEmitter</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="external:EventEmitter_sub"></div></li><li><a href="external-Guild.html">Guild</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="external:Guild_sub"></div></li><li><a href="external-GuildChannel.html">GuildChannel</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="external:GuildChannel_sub"></div></li><li><a href="external-GuildMember.html">GuildMember</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="external:GuildMember_sub"></div></li><li><a href="external-Message.html">Message</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="external:Message_sub"></div></li><li><a href="external-Model.html">Model</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="external:Model_sub"></div></li><li><a href="external-Role.html">Role</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="external:Role_sub"></div></li><li><a href="external-User.html">User</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="external:User_sub"></div></li></ul></div><div class="lnb-api hidden"><h3>Classes</h3><ul><li><a href="CommendCommand.html">CommendCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="CommendCommand_sub"></div></li><li><a href="GameModeCommand.html">GameModeCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="GameModeCommand_sub"></div></li><li><a href="LeaderboardCommand.html">LeaderboardCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="LeaderboardCommand_sub"></div></li><li><a href="LeagueCreateCommand.html">LeagueCreateCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="LeagueCreateCommand_sub"></div></li><li><a href="LeagueInfoCommand.html">LeagueInfoCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="LeagueInfoCommand_sub"></div></li><li><a href="LeagueSeasonCommand.html">LeagueSeasonCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="LeagueSeasonCommand_sub"></div></li><li><a href="LeagueUpdateCommand.html">LeagueUpdateCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="LeagueUpdateCommand_sub"></div></li><li><a href="LobbyCreateCommand.html">LobbyCreateCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="LobbyCreateCommand_sub"></div></li><li><a href="LobbyFirstPickCommand.html">LobbyFirstPickCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="LobbyFirstPickCommand_sub"></div></li><li><a href="LobbyGameModeCommand.html">LobbyGameModeCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="LobbyGameModeCommand_sub"></div></li><li><a href="LobbyInviteCommand.html">LobbyInviteCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="LobbyInviteCommand_sub"></div></li><li><a href="LobbyKickCommand.html">LobbyKickCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="LobbyKickCommand_sub"></div></li><li><a href="LobbyKillCommand.html">LobbyKillCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="LobbyKillCommand_sub"></div></li><li><a href="LobbyStartCommand.html">LobbyStartCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="LobbyStartCommand_sub"></div></li><li><a href="LobbySwapCommand.html">LobbySwapCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="LobbySwapCommand_sub"></div></li><li><a href="module-dotaBot-DotaBot.html">DotaBot</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:dotaBot~DotaBot_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="module-dotaBot-DotaBot.html#accountId">accountId</a></li><li><a href="module-dotaBot-DotaBot.html#backoff">backoff</a></li><li><a href="module-dotaBot-DotaBot.html#backoff">backoff</a></li><li><a href="module-dotaBot-DotaBot.html#lobby">lobby</a></li><li><a href="module-dotaBot-DotaBot.html#rate_limit">rate_limit</a></li><li><a href="module-dotaBot-DotaBot.html#rate_limit">rate_limit</a></li><li><a href="module-dotaBot-DotaBot.html#state">state</a></li><li><a href="module-dotaBot-DotaBot.html#steamId">steamId</a></li><li><a href="module-dotaBot-DotaBot.html#steamid_64">steamid_64</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="module-dotaBot-DotaBot.html#connect">connect</a></li><li><a href="module-dotaBot-DotaBot.html#disconnect">disconnect</a></li><li><a href="module-dotaBot-DotaBot.html#schedule">schedule</a></li></ul></div></li><li><a href="module-ihlManager-IHLManager.html">IHLManager</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:ihlManager~IHLManager_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="module-ihlManager-IHLManager.html#attachEventHandlers">attachEventHandlers</a></li><li><a href="module-ihlManager-IHLManager.html#attachMessageHandlers">attachMessageHandlers</a></li><li><a href="module-ihlManager-IHLManager.html#banInhouseQueue">banInhouseQueue</a></li><li><a href="module-ihlManager-IHLManager.html#checkInhouseQueue">checkInhouseQueue</a></li><li><a href="module-ihlManager-IHLManager.html#createNewLeague">createNewLeague</a></li><li><a href="module-ihlManager-IHLManager.html#createNewLobbyForInhouse">createNewLobbyForInhouse</a></li><li><a href="module-ihlManager-IHLManager.html#init">init</a></li><li><a href="module-ihlManager-IHLManager.html#joinInhouseQueue">joinInhouseQueue</a></li><li><a href="module-ihlManager-IHLManager.html#leaveInhouseQueue">leaveInhouseQueue</a></li><li><a href="module-ihlManager-IHLManager.html#onDraftMember">onDraftMember</a></li><li><a href="module-ihlManager-IHLManager.html#onLobbyKill">onLobbyKill</a></li><li><a href="module-ihlManager-IHLManager.html#onLobbyReady">onLobbyReady</a></li><li><a href="module-ihlManager-IHLManager.html#onLobbyTimedOut">onLobbyTimedOut</a></li><li><a href="module-ihlManager-IHLManager.html#onMatchEnd">onMatchEnd</a></li><li><a href="module-ihlManager-IHLManager.html#onPlayerReady">onPlayerReady</a></li><li><a href="module-ihlManager-IHLManager.html#onPlayersReady">onPlayersReady</a></li><li><a href="module-ihlManager-IHLManager.html#processEventQueue">processEventQueue</a></li><li><a href="module-ihlManager-IHLManager.html#queueEvent">queueEvent</a></li><li><a href="module-ihlManager-IHLManager.html#registerLobbyTimeout">registerLobbyTimeout</a></li><li><a href="module-ihlManager-IHLManager.html#runLobby">runLobby</a></li><li><a href="module-ihlManager-IHLManager.html#unregisterLobbyTimeout">unregisterLobbyTimeout</a></li></ul></div></li><li><a href="module-matchTracker-MatchTracker.html">MatchTracker</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="module:matchTracker~MatchTracker_sub"><div class="member-type">Methods</div><ul class="inner"><li><a href="module-matchTracker-MatchTracker.html#run">run</a></li><li><a href="module-matchTracker-MatchTracker.html#start">start</a></li><li><a href="module-matchTracker-MatchTracker.html#stop">stop</a></li></ul></div></li><li><a href="NicknameCommand.html">NicknameCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="NicknameCommand_sub"></div></li><li><a href="PickCommand.html">PickCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="PickCommand_sub"></div></li><li><a href="Queue.html">Queue</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="Queue_sub"><div class="member-type">Members</div><ul class="inner"><li><a href="Queue.html#backoff">backoff</a></li><li><a href="Queue.html#backoff">backoff</a></li><li><a href="Queue.html#rate_limit">rate_limit</a></li><li><a href="Queue.html#rate_limit">rate_limit</a></li><li><a href="Queue.html#state">state</a></li></ul><div class="member-type">Methods</div><ul class="inner"><li><a href="Queue.html#block">block</a></li><li><a href="Queue.html#clear">clear</a></li><li><a href="Queue.html#release">release</a></li><li><a href="Queue.html#schedule">schedule</a></li></ul></div></li><li><a href="QueueBanCommand.html">QueueBanCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="QueueBanCommand_sub"></div></li><li><a href="QueueClearCommand.html">QueueClearCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="QueueClearCommand_sub"></div></li><li><a href="QueueJoinCommand.html">QueueJoinCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="QueueJoinCommand_sub"></div></li><li><a href="QueueLeaveCommand.html">QueueLeaveCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="QueueLeaveCommand_sub"></div></li><li><a href="QueueReadyCommand.html">QueueReadyCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="QueueReadyCommand_sub"></div></li><li><a href="QueueStatusCommand.html">QueueStatusCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="QueueStatusCommand_sub"></div></li><li><a href="RegisterCommand.html">RegisterCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="RegisterCommand_sub"></div></li><li><a href="RepCommand.html">RepCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="RepCommand_sub"></div></li><li><a href="RolesCommand.html">RolesCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="RolesCommand_sub"></div></li><li><a href="UnrepCommand.html">UnrepCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="UnrepCommand_sub"></div></li><li><a href="WhoisCommand.html">WhoisCommand</a><button type="button" class="hidden toggle-subnav btn btn-link">  <span class="glyphicon glyphicon-plus"></span></button><div class="hidden" id="WhoisCommand_sub"></div></li></ul></div>
</nav>
<div id="resizer"></div>

<div class="main" id="main">
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code> /**
 * @module lobby
 */
 
 /**
 * @typedef module:lobby.LobbyState
 * @type {Object}
 * @property {external:Guild} guild - The discord guild the lobby belongs to.
 * @property {external:CategoryChannel} category - The discord inhouse category.
 * @property {external:GuildChannel} channel - The discord lobby channel.
 * @property {external:Role} role - The discord lobby role.
 * @property {number} ready_check_timeout - Duration in milliseconds before lobby ready timeout. 
 * @property {number} captain_rank_threshold - Maximum rank difference between captains. 
 * @property {string} captain_role_regexp - Regular expression string for captain roles.
 * @property {string} state - The lobby state.
 * @property {number} bot_id - The record id of the bot hosting the lobby.
 * @property {string} lobby_name - The lobby name.
 * @property {string} lobby_id - The in-game lobby id.
 * @property {string} password - The lobby password.
 * @property {string} captain_1 - The first captain steamid64.
 * @property {string} captain_2 - The second captain steamid64.
 * @property {string} match_id - The match id for the lobby.
 */
 
const util = require('util');
const Promise = require('bluebird');
const hri = require('human-readable-ids').hri;
const Sequelize = require('sequelize');
const { isDotaLobbyReady, DotaBot } = require('./dotaBot');

const Op = Sequelize.Op;
const logger = require('./logger');
const shuffle = require('./util/shuffle');
const combinations = require('./util/combinations');
const CONSTANTS = require('./constants');
const {
    findOrCreateChannelInCategory, findOrCreateRole, addRoleToUser, resolveUser,
} = require('./guild');
const {
    findLobby, findOrCreateLobbyForGuild, findBot, updateLobbyState, updateBotStatusBySteamId, updateBotStatus, updateQueueStatesByUserId, destroyQueuesByUserId, findAllUnassignedBot,
} = require('./db');
const {
    pipeP, mapPromise,
} = require('./util/fp');

const getLobby = async lobbyOrState => (lobbyOrState instanceof Sequelize.Model ? lobbyOrState : findLobby(lobbyOrState.lobby_name));

const getPlayers = options => async lobbyOrState => (await getLobby(lobbyOrState)).getPlayers(options);

const getPlayerBySteamId = lobbyOrState => async steamid_64 => (await getPlayers({ where: { steamid_64 } })(lobbyOrState))[0];

const getPlayerByDiscordId = lobbyOrState => async discord_id => (await getPlayers({ where: { discord_id } })(lobbyOrState))[0];

const getNoTeamPlayers = options => async lobbyOrState => (await getLobby(lobbyOrState)).getNoTeamPlayers(options);

const getNotReadyPlayers = options => async lobbyOrState => (await getLobby(lobbyOrState)).getNotReadyPlayers(options);

const getReadyPlayers = options => async lobbyOrState => (await getLobby(lobbyOrState)).getReadyPlayers(options);

const mapPlayers = fn => async lobbyOrState => pipeP(getPlayers(), mapPromise(fn))(lobbyOrState);

const addPlayer = lobbyOrState => async user => (await getLobby(lobbyOrState)).addPlayer(user);

const addPlayers = lobbyOrState => async users => mapPromise(addPlayer(lobbyOrState))(users);

const addRoleToPlayers = async lobbyState => mapPlayers(addRoleToUser(lobbyState.guild)(lobbyState.role))(lobbyState);

/*const setPlayers = options => lobby => async players => lobby.setPlayers(players, options);
const setLobbyPlayers = options => async lobby => pipeP(getPlayers(), setPlayers(options)(lobby))(lobby);
const setLobbyPlayersByLobbyName = options => pipeP(findLobby, setLobbyPlayers(options));
const setPlayersReady = value => setLobbyPlayersByLobbyName({ through: { ready: value } });*/

const updateLobbyPlayer = data => lobbyOrState => async (steamid_64) => {
    logger.debug(`updateLobbyPlayer ${lobbyOrState.lobby_name} ${steamid_64} ${util.inspect(data)}`);
    const [player] = await getPlayers({ where: { steamid_64 } })(lobbyOrState);
    return player.LobbyPlayer.update(data);
};

const setPlayerReady = ready => updateLobbyPlayer({ ready });
const setPlayerTeam = faction => updateLobbyPlayer({ faction });

const calcBalanceTeams = (playersWithRank) => {
    logger.debug('calcBalanceTeams');
    const combs = combinations(playersWithRank, 5);
    let best_weight_diff = 999999;
    let best_pairs = [];
    combs.forEach((comb) => {
        const team_1 = comb;
        const team_2 = playersWithRank.filter(i => comb.indexOf(i) &lt; 0);
        const weight_1 = team_1.reduce((total, playerWithRank) => total + playerWithRank[1], 0);
        const weight_2 = team_2.reduce((total, playerWithRank) => total + playerWithRank[1], 0);
        const weight_diff = Math.abs(weight_1 - weight_2);
        if (weight_diff &lt; best_weight_diff) {
            best_pairs = [[team_1, team_2]];
            best_weight_diff = weight_diff;
        }
        else if (weight_diff === best_weight_diff) {
            best_pairs.push([team_1, team_2]);
        }
    });
    shuffle(best_pairs);
    const best_pair = best_pairs.pop();
    logger.debug(`calcBalanceTeams done. ${best_pair.length}`);
    return best_pair.map(team => team.map(playerWithRank => playerWithRank[0]));
};

const setTeams = lobbyOrState => async ([team_1, team_2]) => {
    const lobby = await getLobby(lobbyOrState);
    return Promise.all([
        lobby.addPlayers(team_1, { through: { faction: 1 } }),
        lobby.addPlayers(team_2, { through: { faction: 2 } }),
    ]);
};

const selectCaptainPairFromTiers = captain_rank_threshold => (tiers) => {
    const keys = Object.keys(tiers).sort().reverse();
    // loop through tiers starting from highest tier
    for (const key of keys) {
        const tier = tiers[key];
        // only look at tiers with at least 2 players in them
        if (tier.length >= 2) {
            // get all possible pairs within the tier
            let combs = combinations(tier, 2);

            // filter out pairs that exceed skill difference threshold
            combs = combs.filter(([[, rank_tier_1], [, rank_tier_2]]) => Math.abs(rank_tier_1 - rank_tier_2) &lt;= captain_rank_threshold);

            // select random pair
            shuffle(combs);

            return combs.pop();
        }
    }
    return [];
};

const sortPlayersByCaptainPriority = (playersWithCaptainPriority) => {
    const tiers = {};
    for (const [player, captain_priority, rank_tier] of playersWithCaptainPriority) {
        if (captain_priority !== -1) {
            tiers[captain_priority] = tiers[captain_priority] || [];
            tiers[captain_priority].push([player, rank_tier]);
        }
    }
    return tiers;
};

const getUserCaptainPriority = (guild, captain_role_regexp, user) => {
    const regexp = new RegExp(captain_role_regexp);
    let max_priority = -1;
    user.roles.forEach((role) => {
        const match = role.name.match(regexp);
        if (match) {
            const captain_priority = parseInt(match[1]);
            if (captain_priority > max_priority) {
                max_priority = captain_priority;
            }
        }
        logger.debug(`getUserCaptainPriority ${role.name} ${match} ${max_priority}`);
    });
    return max_priority;
};

const playerToCaptainPriority = guild => captain_role_regexp => async player => [player, getUserCaptainPriority(guild, captain_role_regexp, await resolveUser(guild, player)), player.rank_tier];
const getPlayersWithCaptainPriority = guild => captain_role_regexp => async lobbyOrState => mapPlayers(playerToCaptainPriority(guild)(captain_role_regexp))(lobbyOrState);

const assignCaptains = async lobbyOrState => pipeP(
    getPlayersWithCaptainPriority(lobbyOrState.guild)(lobbyOrState.captain_role_regexp),
    sortPlayersByCaptainPriority,
    selectCaptainPairFromTiers(lobbyOrState.captain_rank_threshold),
)(lobbyOrState);

const calcDefaultGameMode = (game_mode_preferences) => {
    const game_mode_totals = {};
    game_mode_preferences.forEach((game_mode_preference) => {
        game_mode_totals[game_mode_preference] = (game_mode_totals[game_mode_preference] || 0) + 1;
    });

    let best_count = -1;
    let best_game_mode = CONSTANTS.DOTA_GAMEMODE_CM;
    for (const [game_mode, count] of Object.entries(game_mode_totals)) {
        if (count > best_count) {
            best_count = count;
            best_game_mode = game_mode;
        }
    }

    logger.debug(`calcDefaultGameMode ${util.inspect(game_mode_totals)} ${best_count} ${best_game_mode}`);
    return best_game_mode;
};

const autoBalanceTeams = async lobbyOrState => pipeP(
    mapPlayers(player => [player, parseInt(player.rank_tier)]),
    calcBalanceTeams,
    setTeams(lobbyOrState),
)(lobbyOrState);

const getDefaultGameMode = async lobbyOrState => pipeP(
    mapPlayers(player => player.game_mode_preference),
    calcDefaultGameMode,
)(lobbyOrState);

const getDraftingFaction = async (lobbyOrState) => {
    const playersNoTeam = await getNoTeamPlayers()(lobbyOrState);
    const unassignedCount = playersNoTeam.length;
    if (unassignedCount === 0) {
        return 0;
    }
    return [8, 5, 4, 1].indexOf(unassignedCount) !== -1 ? 1 : 2;
};

const getFactionCaptain = lobbyOrState => async faction => (faction > 0 ? getPlayerBySteamId(lobbyOrState)([lobbyOrState.captain_1, lobbyOrState.captain_2][faction - 1]) : null);

const isPlayerDraftable = lobbyOrState => async (player) => {
    if (player.steamid_64 === lobbyOrState.captain_1 || player.steamid_64 === lobbyOrState.captain_2) {
        logger.debug(`isPlayerDraftable INVALID_DRAFT_CAPTAIN ${player.steamid_64} ${player.steamid_64 === lobbyOrState.captain_1} ${player.steamid_64 === lobbyOrState.captain_2}`);
        return CONSTANTS.INVALID_DRAFT_CAPTAIN;
    }
    if (player.faction !== 0) {
        logger.debug(`isPlayerDraftable INVALID_DRAFT_PLAYER ${player.steamid_64}`);
        return CONSTANTS.INVALID_DRAFT_PLAYER;
    }

    logger.debug(`isPlayerDraftable ${player.steamid_64} drafted to faction ${lobbyOrState.currentPick}`);
    await player.update({ faction: lobbyOrState.currentPick });
    return CONSTANTS.PLAYER_DRAFTED;
};

const isCaptain = lobbyOrState => async discord_id => (await getPlayers()(lobbyOrState)({
    discord_id,
    steamid_64: {
        [Op.in]: [lobbyOrState.captain_1, lobbyOrState.captain_2],
    },
}))[0];

const resetLobbyState = (state) => {
    switch (state) {
    case CONSTANTS.STATE_CHECKING_READY:
        return CONSTANTS.STATE_BEGIN_READY;
    case CONSTANTS.STATE_BOT_STARTED:
    case CONSTANTS.STATE_WAITING_FOR_PLAYERS:
        return CONSTANTS.WAITING_FOR_BOT;
    default:
        return state;
    }
};

const connectDotaBot = async (dotaBot) => {
    logger.debug(`connectDotaBot ${dotaBot.steamid_64}`);
    await dotaBot.connect();
    await updateBotStatusBySteamId(CONSTANTS.BOT_ONLINE)(dotaBot.steamid_64);
    return dotaBot;
};

const disconnectDotaBot = async (dotaBot) => {
    logger.debug(`disconnectDotaBot ${dotaBot.steamid_64}`);
    await dotaBot.disconnect();
    await updateBotStatusBySteamId(CONSTANTS.BOT_OFFLINE)(dotaBot.steamid_64);
    return dotaBot;
};

const createDotaBotLobby = lobbyState => async (dotaBot) => {
    logger.debug(`createDotaBotLobby ${lobbyState.lobby_name} ${lobbyState.pass_key}`);
    await dotaBot.createPracticeLobby({ game_name: lobbyState.lobby_name, pass_key: lobbyState.pass_key });
    await updateBotStatusBySteamId(CONSTANTS.BOT_IN_LOBBY)(dotaBot.steamid_64);
    return dotaBot;
};

const joinDotaBotLobby = lobbyState => async (dotaBot) => {
    logger.debug(`joinDotaBotLobby ${lobbyState.lobby_name} ${lobbyState.pass_key}`);
    await dotaBot.joinPracticeLobby(lobbyState.lobby_id, { game_name: lobbyState.lobby_name, pass_key: lobbyState.pass_key });
    await updateBotStatusBySteamId(CONSTANTS.BOT_IN_LOBBY)(dotaBot.steamid_64);
    return dotaBot;
};

const reducePlayerToFactionCache = (_factionCache, player) => {
    const factionCache = { ..._factionCache };
    factionCache[player.steamid_64] = player.LobbyPlayer.faction;
    return factionCache;
};

const setupLobbyBot = async (lobbyState) => {
    logger.debug(`setupLobbyBot ${lobbyState.lobby_name} ${lobbyState.bot_id} ${lobbyState.password}`);
    let dotaBot;
    try {
        await updateBotStatus(CONSTANTS.BOT_LOADING)(lobbyState.bot_id);
        const config = await findBot(lobbyState.bot_id);
        dotaBot = new DotaBot(config, true, false);
        await connectDotaBot(dotaBot);
        if (lobbyState.lobby_id) {
            await joinDotaBotLobby(lobbyState)(dotaBot);
        }
        else {
            await createDotaBotLobby(lobbyState)(dotaBot);
        }
        dotaBot.factionCache = (await getPlayers()(lobbyState)).reduce(reducePlayerToFactionCache);
        return dotaBot;
    }
    catch (err) {
        if (dotaBot) {
            await disconnectDotaBot(dotaBot);
        }
        return null;
    }
};

const killLobby = async (_lobbyState) => {
    logger.debug('killLobby');
    const lobbyState = { ..._lobbyState };
    
    const ready_user_ids = await mapPromise(player => player.user_id)(getReadyPlayers()(lobbyState));
    const unready_user_ids = await mapPromise(player => player.user_id)(getNotReadyPlayers()(lobbyState));

    await updateQueueStatesByUserId(CONSTANTS.QUEUE_IN_QUEUE)(ready_user_ids);
    await destroyQueuesByUserId(unready_user_ids);

    if (lobbyState.channel) {
        logger.debug('killLobby channel delete');
        await lobbyState.channel.delete();
    }

    if (lobbyState.role) {
        logger.debug('killLobby role delete');
        await lobbyState.role.delete();
    }

    if (lobbyState.dotaBot) {
        logger.debug('killLobby bot delete');
        await disconnectDotaBot(lobbyState.dotaBot);
    }
    

    lobbyState.state = CONSTANTS.STATE_KILLED;
    lobbyState.channel = null;
    lobbyState.role = null;
    lobbyState.dotaBot = null;
    return lobbyState;
};

const isReadyCheckTimedOut = (ready_check_timeout, ready_check_time) => ready_check_time + ready_check_timeout &lt; Date.now();

const reducePlayersToFactionCache = (players) => {
    const factionCache = {};
    players.forEach((player) => {
        factionCache[player.steamid_64] = player.LobbyPlayer.faction;
    });
    return factionCache;
};

const invitePlayer = dotaBot => async player => dotaBot.inviteToLobby(player.steamid_64);

const getUnassignedBot = async () => {
    logger.debug('getUnassignedBot');
    const bots = await findAllUnassignedBot();
    if (bots.length) {
        logger.debug(`getUnassignedBot assigned steamid_64 ${bots[0].steamid_64}`);
        return bots[0];
    }

    logger.debug('getUnassignedBot bot unavailable');
    return null;
};

const startLobby = async (lobbyState) => {
    logger.debug('startLobby');
    const lobbyData = await lobbyState.dotaBot.launchPracticeLobby();
    await lobbyState.dotaBot.leavePracticeLobby().then(() => {
        // TODO: check if this resolves
        lobbyState.dotaBot.abandonCurrentGame()
            .then(() => logger.debug('startLobby bot abandoned current game'))
            .catch(console.error);
    });
    await disconnectDotaBot(lobbyState.dotaBot);
    const user_ids = await mapPlayers(player => player.user_id)(lobbyState);
    await updateQueueStatesByUserId(CONSTANTS.QUEUE_IN_GAME)(user_ids);
    return lobbyData.match_id;
};

const getLobbyRole = guild => async (lobby_name) => {
    const role = await findOrCreateRole(guild, lobby_name);
    await role.setPermissions([]);
    await role.setMentionable(true);
    return role;
};

const loadLobby = async ({
    guild, category, lobby_name, ready_check_timeout, captain_rank_threshold, captain_role_regexp,
}) => {
    const lobby = await findOrCreateLobbyForGuild(guild.id, lobby_name);
    const channel = await findOrCreateChannelInCategory(guild, category, lobby_name);
    const role = await getLobbyRole(guild)(lobby_name);
    const state = await resetLobbyState(lobby.state);
    const lobbyState = {
        guild,
        category,
        channel,
        role,
        ready_check_timeout,
        captain_rank_threshold,
        captain_role_regexp,
        state,
        bot_id: lobby.bot_id,
        lobby_name: lobby.lobby_name,
        lobby_id: lobby.lobby_id,
        password: lobby.password,
        captain_1: lobby.captain_1,
        captain_2: lobby.captain_2,
        match_id: lobby.match_id,
    };
    await addRoleToPlayers(lobbyState);
    logger.debug(`loadLobby done ${lobby_name}`);
    updateLobbyState(lobbyState);
    return lobbyState;
};

const initLobby = async ({
    guild, category, ready_check_timeout, captain_rank_threshold, captain_role_regexp,
}) => {
    const lobby_name = hri.random();
    const lobby = await findLobby(lobby_name);
    if (!lobby) {
        logger.debug(`initLobby lobby_name ${lobby_name} not exists, creating`);
        return loadLobby({
            guild, category, lobby_name, ready_check_timeout, captain_rank_threshold, captain_role_regexp,
        });
    }

    logger.debug(`initLobby lobby_name ${lobby_name} exists, retrying`);
    return initLobby({
        guild, category, ready_check_timeout, captain_rank_threshold, captain_role_regexp,
    });
};

const LobbyStateHandlers = {
    [CONSTANTS.STATE_NEW]: async (_lobbyState) => {
        const lobbyState = { ..._lobbyState };
        const events = [];
        lobbyState.state = CONSTANTS.STATE_BEGIN_READY;
        lobbyState.game_mode = await getDefaultGameMode(lobbyState);
        return { lobbyState, events };
    },
    [CONSTANTS.STATE_BEGIN_READY]: async (_lobbyState) => {
        const lobbyState = { ..._lobbyState };
        const events = [];
        if (!lobbyState.ready_check_time) {
            lobbyState.ready_check_time = Date.now();
            events.push(CONSTANTS.EVENT_READY_CHECK_START);
        }
        lobbyState.state = CONSTANTS.STATE_CHECKING_READY;
        return { lobbyState, events };
    },
    [CONSTANTS.STATE_CHECKING_READY]: async (_lobbyState) => {
        let lobbyState = { ..._lobbyState };
        const events = [];
        const playersNotReady = await getNotReadyPlayers()(lobbyState);
        logger.debug(`runLobby playersNotReady ${playersNotReady.length}`);
        if (!playersNotReady.length) {
            lobbyState.state = CONSTANTS.STATE_ASSIGNING_CAPTAINS;
            events.push(CONSTANTS.EVENT_PLAYERS_READY);
        }
        else if (isReadyCheckTimedOut(lobbyState.ready_check_timeout, lobbyState.ready_check_time)) {
            events.push(CONSTANTS.EVENT_READY_CHECK_FAILED);
            lobbyState = await killLobby(lobbyState);
        }
        return { lobbyState, events };
    },
    [CONSTANTS.STATE_ASSIGNING_CAPTAINS]: async (_lobbyState) => {
        const lobbyState = { ..._lobbyState };
        const events = [];
        if (!lobbyState.captain_1 || !lobbyState.captain_2) {
            const [captain_1, captain_2] = await assignCaptains(lobbyState);
            logger.debug(`lobby run assignCaptains captain_1 ${util.inspect(lobbyState.captain_1)} captain_2 ${util.inspect(lobbyState.captain_2)}`);
            lobbyState.state = (captain_1 &amp;&amp; captain_2) ? CONSTANTS.STATE_CHOOSING_SIDE : CONSTANTS.STATE_AUTOBALANCING;
            lobbyState.captain_1 = captain_1 ? captain_1.steamid_64 : null;
            lobbyState.captain_2 = captain_2 ? captain_2.steamid_64 : null;
            events.push(CONSTANTS.EVENT_ASSIGNED_CAPTAINS);
        }
        else {
            logger.debug(`lobby run assignCaptains captains exist ${lobbyState.captain_1}, ${lobbyState.captain_2}`);
            lobbyState.state = CONSTANTS.STATE_CHOOSING_SIDE;
        }
        return { lobbyState, events };
    },
    [CONSTANTS.STATE_CHOOSING_SIDE]: async (_lobbyState) => {
        const lobbyState = { ..._lobbyState };
        const events = [];
        await setPlayerTeam(1)(lobbyState)(lobbyState.captain_1);
        await setPlayerTeam(2)(lobbyState)(lobbyState.captain_2);
        lobbyState.state = CONSTANTS.STATE_DRAFTING_PLAYERS;
        return { lobbyState, events };
    },
    [CONSTANTS.STATE_DRAFTING_PLAYERS]: async (_lobbyState) => {
        const lobbyState = { ..._lobbyState };
        const events = [];
        lobbyState.faction = getDraftingFaction(lobbyState);
        const lobbyPlayer = await getFactionCaptain(lobbyState);
        logger.debug(`lobby run playerDraft lobbyPlayer ${util.inspect(lobbyPlayer)}`);
        if (lobbyPlayer) {
            lobbyState.currentPick = lobbyPlayer.faction;
            events.push(CONSTANTS.EVENT_DRAFT_TURN);
        }
        else {
            lobbyState.state = CONSTANTS.STATE_TEAMS_SELECTED;
        }
        return { lobbyState, events };
    },
    [CONSTANTS.STATE_AUTOBALANCING]: async (_lobbyState) => {
        const lobbyState = { ..._lobbyState };
        const events = [];
        events.push(CONSTANTS.EVENT_AUTOBALANCING);
        const playersNoTeam = await getNoTeamPlayers()(lobbyState);
        const unassignedCount = playersNoTeam.length;
        if (unassignedCount) {
            logger.debug('Autobalancing...');
            await autoBalanceTeams(lobbyState);
            logger.debug('Autobalancing... done');
        }
        lobbyState.state = CONSTANTS.STATE_TEAMS_SELECTED;
        return { lobbyState, events };
    },
    [CONSTANTS.STATE_TEAMS_SELECTED]: async (_lobbyState) => {
        const lobbyState = { ..._lobbyState };
        const events = [];
        lobbyState.state = CONSTANTS.STATE_WAITING_FOR_BOT;
        events.push(CONSTANTS.EVENT_TEAMS_SELECTED);
        return { lobbyState, events };
    },
    [CONSTANTS.STATE_WAITING_FOR_BOT]: async (_lobbyState) => {
        const lobbyState = { ..._lobbyState };
        const events = [];
        if (!lobbyState.bot_id) {
            const bot = await getUnassignedBot();
            if (bot) {
                logger.debug(`lobby run getUnassignedBot ${bot.steamid_64}`);
                lobbyState.state = CONSTANTS.STATE_BOT_ASSIGNED;
                lobbyState.bot_id = bot.id;
            }
            else {
                lobbyState.state = CONSTANTS.STATE_WAITING_FOR_BOT;
                lobbyState.bot_id = null;
                lobbyState.lobby_id = null;
            }
        }
        else {
            lobbyState.state = CONSTANTS.STATE_BOT_ASSIGNED;
        }
        return { lobbyState, events };
    },
    [CONSTANTS.STATE_BOT_ASSIGNED]: async (_lobbyState) => {
        const lobbyState = { ..._lobbyState };
        const events = [];
        const dotaBot = await setupLobbyBot(lobbyState);
        logger.debug(`lobby run setupLobbyBot dotaBot exists ${!!dotaBot}`);
        if (dotaBot) {
            lobbyState.dotaBot = dotaBot;
            lobbyState.lobby_id = dotaBot.lobby_id;
            lobbyState.state = CONSTANTS.STATE_BOT_STARTED;
        }
        else {
            lobbyState.state = CONSTANTS.STATE_WAITING_FOR_BOT;
            lobbyState.bot_id = null;
            lobbyState.lobby_id = null;
        }
        return { lobbyState, events };
    },
    [CONSTANTS.STATE_BOT_STARTED]: async (_lobbyState) => {
        const lobbyState = { ..._lobbyState };
        const events = [];
        lobbyState.state = CONSTANTS.STATE_WAITING_FOR_PLAYERS;
        await mapPlayers(invitePlayer(lobbyState.dotaBot))(lobbyState);
        return { lobbyState, events };
    },
    [CONSTANTS.STATE_WAITING_FOR_PLAYERS]: async (_lobbyState) => {
        const lobbyState = { ..._lobbyState };
        const events = [];
        if (isDotaLobbyReady(lobbyState.dotaBot.factionCache, lobbyState.dotaBot.playerState)) {
            logger.debug('lobby run isDotaLobbyReady true');
            lobbyState.state = CONSTANTS.STATE_MATCH_IN_PROGRESS;
            lobbyState.match_id = await startLobby(lobbyState);
            events.push(CONSTANTS.EVENT_LOBBY_STARTED);
            logger.debug(`lobby run lobby started match_id ${lobbyState.match_id}`);
        }
        else {
            logger.debug('lobby run isDotaLobbyReady false');
        }
        return { lobbyState, events };
    },
    [CONSTANTS.STATE_MATCH_IN_PROGRESS]: async (_lobbyState) => {
        const lobbyState = { ..._lobbyState };
        const events = [];
        logger.debug('lobby run ending match');
        lobbyState.state = CONSTANTS.STATE_MATCH_ENDED;
        const user_ids = await mapPlayers(player => player.user_id)(lobbyState);
        await destroyQueuesByUserId(user_ids);
        logger.debug(`lobby run state ${lobbyState.state}`);
        return { lobbyState, events };
    },
    [CONSTANTS.STATE_MATCH_ENDED]: async (_lobbyState) => {
        const lobbyState = { ..._lobbyState };
        const events = [];
        logger.debug('lobby run match ended');
        return { lobbyState, events };
    },
};

const runLobby = async (_lobbyState, eventEmitter) => {
    const { lobbyState, events } = await LobbyStateHandlers[_lobbyState.state](_lobbyState);
    logger.debug(`runLobby ${util.inspect(_lobbyState.state)} ${util.inspect(lobbyState.state)}`);
    events.forEach(event => eventEmitter.emit(event, lobbyState));
    if (lobbyState.state === CONSTANTS.STATE_BOT_STARTED) {
        lobbyState.dotaBot.on(CONSTANTS.EVENT_CHAT_MESSAGE, (channel, sender_name, message, chatData) => eventEmitter.emit(CONSTANTS.EVENT_CHAT_MESSAGE, lobbyState, channel, sender_name, message, chatData));
        lobbyState.dotaBot.on(CONSTANTS.EVENT_LOBBY_PLAYER_JOINED, member => eventEmitter.emit(CONSTANTS.EVENT_LOBBY_PLAYER_JOINED, lobbyState, member));
        lobbyState.dotaBot.on(CONSTANTS.EVENT_LOBBY_PLAYER_LEFT, member => eventEmitter.emit(CONSTANTS.EVENT_LOBBY_PLAYER_LEFT, lobbyState, member));
        lobbyState.dotaBot.on(CONSTANTS.EVENT_LOBBY_PLAYER_CHANGED_SLOT, state => eventEmitter.emit(CONSTANTS.EVENT_LOBBY_PLAYER_CHANGED_SLOT, lobbyState, state));
        lobbyState.dotaBot.on(CONSTANTS.EVENT_LOBBY_READY, () => eventEmitter.emit(CONSTANTS.EVENT_LOBBY_READY, lobbyState));
    }
    await updateLobbyState(lobbyState);
    if (lobbyState.state !== _lobbyState.state) {
        logger.debug('runLobby continue');
        return runLobby(lobbyState, eventEmitter);
    }

    logger.debug('runLobby stop');
    return lobbyState;
};

module.exports = {
    getLobby,
    getPlayers,
    getPlayerBySteamId,
    getPlayerByDiscordId,
    getNoTeamPlayers,
    getNotReadyPlayers,
    addRoleToPlayers,
    addPlayers,
    //setPlayers,
    mapPlayers,
    //setLobbyPlayers,
    //setLobbyPlayersByLobbyName,
    //setPlayersReady,
    setPlayerReady,
    setPlayerTeam,
    calcBalanceTeams,
    selectCaptainPairFromTiers,
    sortPlayersByCaptainPriority,
    setTeams,
    getUserCaptainPriority,
    assignCaptains,
    calcDefaultGameMode,
    autoBalanceTeams,
    getDefaultGameMode,
    getDraftingFaction,
    getFactionCaptain,
    isPlayerDraftable,
    isCaptain,
    resetLobbyState,
    updateLobbyState,
    connectDotaBot,
    disconnectDotaBot,
    createDotaBotLobby,
    setupLobbyBot,
    killLobby,
    isReadyCheckTimedOut,
    reducePlayersToFactionCache,
    getUnassignedBot,
    startLobby,
    loadLobby,
    initLobby,
    runLobby,
    LobbyStateHandlers,
};
</code></pre>
        </article>
    </section>




</div>

<footer>
    <img class="logo" src="img/toast-ui.png" style="">
    <div class="footer-text">https://github.com/devilesk/dota-ihl-bot</div>
</footer>
<script>prettyPrint();</script>
<script src="scripts/jquery.min.js"></script>
<script src="scripts/tui-doc.js"></script>
<script src="scripts/linenumber.js"></script>

    <script>
        var id = '_sub'.replace(/"/g, '_');
        var selectedApi = document.getElementById(id); // do not use jquery selector
        var $selectedApi = $(selectedApi);

        $selectedApi.removeClass('hidden');
        $selectedApi.parent().find('.glyphicon').removeClass('glyphicon-plus').addClass('glyphicon-minus');
        showLnbApi();
    </script>

</body>
</html>
